#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  ForkTouch,      sensorTouch)
#pragma config(Sensor, dgtl2,  FloorTouch,     sensorTouch)
#pragma config(Sensor, dgtl3,  LEDGreen,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  LEDAmber,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LEDRed,         sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port3,           DFrontLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           DLateral,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           DBackLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port6,           LeftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           DBackRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port8,           DFrontRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           RightLift,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(300)
#pragma userControlDuration(900)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
/**
Port	Use
2	Left Lift
9	Right Lift
3	D Front Left
8	D Front Right
4	D Lateral
5	D Back Right
7	D Back Left
*/
int cap(int x) {
	if (x < 30) {
		if (x > -30) return 0;
		if (x < -127) return -127;
	}
	if (x > 127) return 127;

	return x;
}

void control() {

	int HORRIZONTAL_AXIS = 0;
	int VERTICAL_AXIS = 1;

	//int deltaTime = time1[T1];
	//clearTimer(T1);
//Xmtr2
	//Get the data
	int mainLeftStick[] = {vexRT[Ch4], vexRT[Ch3]};
	int mainRightStick[] = {vexRT[Ch1], vexRT[Ch2]};

	int partnerLeftStick[] = {vexRT[Ch4Xmtr2], vexRT[Ch3Xmtr2]};
	int partnerRightStick[] = {vexRT[Ch1Xmtr2], vexRT[Ch2Xmtr2]};

	int armMotorPosition = SensorValue(I2C_1);
	int armMotorPosition3 = SensorValue(armPot);

	//motor[DLateral]  = cap(leftStick[HORRIZONTAL_AXIS]);
	motor[DBackLeft] = cap(mainLeftStick[VERTICAL_AXIS]);
	motor[DFrontLeft]= cap(mainLeftStick[VERTICAL_AXIS]);
	motor[DBackRight] = cap(mainRightStick[VERTICAL_AXIS]);
	motor[DFrontRight]= cap(mainRightStick[VERTICAL_AXIS]);

	motor[DLateral]= (vexRT[Btn6U]-vexRT[Btn5U]) * 127;

	motor[LeftLift] = cap(partnerRightStick[VERTICAL_AXIS]);
	motor[RightLift] = cap(partnerRightStick[VERTICAL_AXIS]);


	//string debug;
	//sprintf(debug,"%d",armMotorPosition);
	//datalogAddValue(0, armMotorPosition);
	//datalogAddValue(2, armMotorPosition3);

	//motor[leftMotor] = leftStick[VERTICAL_AXIS];
	//motor[rightMotor] = rightStick[VERTICAL_AXIS];

	//motor[armMotor] = leftStick[HORRIZONTAL_AXIS];
	//motor[clawMotor] = rightStick[HORRIZONTAL_AXIS];
	//motor[armMotor] = (vexRT[Btn5D] - vexRT[Btn5U]) * 127;
	//motor[clawMotor] = (vexRT[Btn6D] - vexRT[Btn6U]) * 127;
	datalogAddValue(0, SensorValue[armPot]);
}



void pre_auton()
{

}
task autonomous()
{
	SensorValue[LEDGreen] = true;
}
task usercontrol()
{
	SensorValue[LEDGreen] = true;
	SensorValue[LEDRed] = true;
	SensorValue[LEDAmber] = true;

	//clearTimer(T1);
	//int a =0;
	//nMotorEncoder[armMotor] = 0;
	//datalogAddValue(4, 100);
	while (true) {

		//motor[leftMotor] = 100;
		control();

	}
}
