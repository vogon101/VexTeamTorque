#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           rightMotor1,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftMotor1,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           armMotor,      tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port5,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           sideMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftMotor2,    tmotorNone, openLoop)
#pragma config(Motor,  port8,           rightMotor2,   tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*

	Port2 - left hand drive motor
	Port3 - right hand drive motor
	Port4 - arm up and down
	Prot5 - claw motor

*/

int cap(int x) {
	if (x < 30) {
		if (x > -30) return 0;
		if (x < -127) return -127;
	}
	if (x > 127) return 127;

	return x;
}

void control() {

	int HORRIZONTAL_AXIS = 0;
	int VERTICAL_AXIS = 1;

	int deltaTime = time1[T1];
	clearTimer(T1);

	//Get the data
	int leftStick[] = {vexRT[Ch4], vexRT[Ch3]};
	int rightStick[] = {vexRT[Ch1], vexRT[Ch2]};

	int armMotorPosition = SensorValue(I2C_1);
	int armMotorPosition3 = SensorValue(armPot);

	motor[sideMotor]  = cap(leftStick[HORRIZONTAL_AXIS]);
	motor[leftMotor1] = cap(leftStick[VERTICAL_AXIS]);
	motor[leftMotor2] = cap(leftStick[VERTICAL_AXIS]);
	motor[rightMotor1]= cap(leftStick[VERTICAL_AXIS]);
	motor[rightMotor2]= cap(leftStick[VERTICAL_AXIS]);


	string debug;
	sprintf(debug,"%d",armMotorPosition);
	datalogAddValue(0, armMotorPosition);
	//datalogAddValue(2, armMotorPosition3);

	//motor[leftMotor] = leftStick[VERTICAL_AXIS];
	//motor[rightMotor] = rightStick[VERTICAL_AXIS];

	//motor[armMotor] = leftStick[HORRIZONTAL_AXIS];
	//motor[clawMotor] = rightStick[HORRIZONTAL_AXIS];
	//motor[armMotor] = (vexRT[Btn5D] - vexRT[Btn5U]) * 127;
	//motor[clawMotor] = (vexRT[Btn6D] - vexRT[Btn6U]) * 127;


}

task main()
{

	clearTimer(T1);
	int a =0;
	//nMotorEncoder[armMotor] = 0;
	//datalogAddValue(4, 100);
	while (true) {

		a = a +1;

		//motor[leftMotor] = 100;
		control();

	}

}
