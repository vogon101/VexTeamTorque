#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  ForkTouch,      sensorTouch)
#pragma config(Sensor, dgtl3,  LEDGreen,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  LEDAmber,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LEDRed,         sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  Encoder_Left,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  Encoder_Lift,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           DBackLeft,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           DFrontRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           DLateral,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LeftLift,      tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port5,           RightLiftUpper, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           RightLiftLower, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           DFrontLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           DBackRight,    tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(300)
#pragma userControlDuration(900)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "control.c"
#include "utils.c"
/**
Port	Use
2	Left Lift
9	Right Lift
3	D Front Left
8	D Front Right
4	D Lateral
5	D Back Right
7	D Back Left
*/



void control() {

	int HORRIZONTAL_AXIS = 0;
	int VERTICAL_AXIS = 1;

	//int deltaTime = time1[T1];
	//clearTimer(T1);
//Xmtr2
	//Get the data
	int mainLeftStick[] = {vexRT[Ch4], vexRT[Ch3]};
	int mainRightStick[] = {vexRT[Ch1], vexRT[Ch2]};

	int partnerLeftStick[] = {vexRT[Ch4Xmtr2], vexRT[Ch3Xmtr2]};
	int partnerRightStick[] = {vexRT[Ch1Xmtr2], vexRT[Ch2Xmtr2]};


	//motor[DLateral]  = cap(leftStick[HORRIZONTAL_AXIS]);
	motor[DBackLeft] = cap(mainLeftStick[VERTICAL_AXIS]);
	motor[DFrontLeft]= cap(mainLeftStick[VERTICAL_AXIS]);
	motor[DBackRight] = cap(mainRightStick[VERTICAL_AXIS]);
	motor[DFrontRight]= cap(mainRightStick[VERTICAL_AXIS]);

	motor[DLateral]= (vexRT[Btn6U]-vexRT[Btn5U]) * 127;

	if (vexRT[Btn7DXmtr2] == 1){
		motor[LeftLift] = cap(partnerRightStick[VERTICAL_AXIS]);
		motor[RightLiftLower] = cap(partnerRightStick[VERTICAL_AXIS]);
		motor[RightLiftUpper] = cap(partnerRightStick[VERTICAL_AXIS]);
	}
	else if (vexRT[Btn6UXmtr2]) {
		control_hold();
	}
	else if (vexRT[Btn5UXmtr2]) {
		control_throw();
	} else {
		control_stop_arm();
	}

	if (vexRT[Btn5D] == 1) {
			control_spin(true);
	}
	if (vexRT[Btn6D] == 1) {
		control_spin(false);
	}

	while (vexRT[Btn7U] || vexRT[Btn7UXmtr2]) {
		control_stop_arm();
		control_stop_drive();
	}

	calibrate_pot();
	checkPot();


	//string debug;
	//sprintf(debug,"%d",armMotorPosition);
	//datalogAddValue(0, armMotorPosition);
	//datalogAddValue(2, armMotorPosition3);

	//motor[leftMotor] = leftStick[VERTICAL_AXIS];
	//motor[rightMotor] = rightStick[VERTICAL_AXIS];

	//motor[armMotor] = leftStick[HORRIZONTAL_AXIS];
	//motor[clawMotor] = rightStick[HORRIZONTAL_AXIS];
	//motor[armMotor] = (vexRT[Btn5D] - vexRT[Btn5U]) * 127;
	//motor[clawMotor] = (vexRT[Btn6D] - vexRT[Btn6U]) * 127;
	datalogAddValue(6, get_pot_raw());

}




void pre_auton()
{
 	SensorValue[LEDGreen] = false;
	SensorValue[LEDAmber] = false;
	SensorValue[LEDRed] = false;
}

task autonomous()
{
	AUTONOMOUS_CODE = true;
	clearTimer(T1);
	nMotorEncoder[DBackLeft] = 0;
	control_move_dist(3);
	control_stop_drive();
	//control_move_dist(1, -1);
	AUTONOMOUS_CODE = false;
}

task usercontrol()
{
	//clearTimer(T1);
	//int a =0;
	//nMotorEncoder[armMotor] = 0;
	//datalogAddValue(4, 100);
	//TODO: Dont allow control in auton mode
 	calibrate_pot();
	while(true) {
		//datalogAddValue(1, nMotorEncoder[DBackLeft]);
		datalogAddValue(1, get_pot());
		control();
	}


 	/**
 	nMotorEncoder[DBackLeft] = 0;
	while(nMotorEncoder[DBackLeft] <= 500) {
		datalogAddValue(2, nMotorEncoder[DBackLeft]);
		control_drive_fw(127);
		sleep(2);
	}
	control_stop_drive();
	sleep(2000);
	SensorValue[LEDGreen] = true;

	nMotorEncoder[DBackRight] = 0;
	while(nMotorEncoder[DBackRight] <= 500) {
		datalogAddValue(1, nMotorEncoder[DBackRight])
		control_drive_fw(127);
		sleep(2);
	}
	control_stop_drive();
	*/
	//control_move_dist(1);

}
